% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tfb-spline.R
\name{tfb_spline}
\alias{tfb_spline}
\alias{tfb_spline.data.frame}
\alias{tfb_spline.matrix}
\alias{tfb_spline.numeric}
\alias{tfb_spline.list}
\alias{tfb_spline.tfd}
\alias{tfb_spline.tfb}
\alias{tfb_spline.default}
\title{Spline-based representation of functional data}
\usage{
tfb_spline(data, ...)

\method{tfb_spline}{data.frame}(
  data,
  id = 1,
  arg = 2,
  value = 3,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  resolution = NULL,
  ...
)

\method{tfb_spline}{matrix}(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  resolution = NULL,
  ...
)

\method{tfb_spline}{numeric}(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  resolution = NULL,
  ...
)

\method{tfb_spline}{list}(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  resolution = NULL,
  ...
)

\method{tfb_spline}{tfd}(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  resolution = NULL,
  ...
)

\method{tfb_spline}{tfb}(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  resolution = NULL,
  ...
)

\method{tfb_spline}{default}(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  resolution = NULL,
  ...
)
}
\arguments{
\item{data}{a \code{matrix}, \code{data.frame} or \code{list} of suitable shape, or another
\code{tf}-object containing functional data.}

\item{...}{arguments to the calls to \code{\link[mgcv:s]{mgcv::s()}} setting up the basis and
\code{\link[mgcv:magic]{mgcv::magic()}} or \code{\link[mgcv:gam.fit]{mgcv::gam.fit()}} (if \code{penalized} is TRUE). If not user-specified here,
\code{tidyfun} uses \code{k = 25} cubic regression spline basis functions
(i.e., \code{bs = "cr"}) by default, but this should (!) be set appropriately.}

\item{id}{The name/number of the column defining which data belong to which function.}

\item{arg}{\code{numeric}, or list of \code{numeric}s. The evaluation grid. See Details on its
interplay with \code{resolution}.
For the \code{data.frame}-method: the name/number of the column defining the
evaluation grid. The \code{matrix} method will try to guess suitable \code{arg}-values
from the column names of \code{data} if \code{arg} is not supplied. Other methods fall back on
integer sequences (\verb{1:<length of data>}) as the default if not provided.}

\item{value}{The name/number of the column containing the function evaluations.}

\item{domain}{range of the \code{arg}.}

\item{penalized}{should the coefficients of the basis representation be estimated
via \code{\link[mgcv:magic]{mgcv::magic()}} (default) or ordinary least squares.}

\item{global}{Defaults to \code{FALSE}.
If \code{TRUE} and \code{penalized = TRUE}, all functions share the same smoothing
parameter (see Details).}

\item{resolution}{resolution of the evaluation grid. See details for \code{\link[=tfd]{tfd()}}.}
}
\value{
a \code{tfb}-object
}
\description{
Represent curves as a weighted sum of spline basis functions.
}
\details{
The basis to be used is set up via a call to \code{\link[mgcv:s]{mgcv::s()}} and all the spline bases
discussed in \code{\link[mgcv:smooth.terms]{mgcv::smooth.terms()}} are available, in principle. Depending on
the value of the \code{penalized}- and \code{global}-flags, the coefficient vectors for each
observation are then estimated via fitting a GAM
(separately for each observation, if \code{!global})
via \code{\link[mgcv:magic]{mgcv::magic()}} (least square error, the default)
or \code{\link[mgcv:gam]{mgcv::gam()}} (if a \code{family} argument was supplied) or
unpenalized least squares / maximum likelihood.

After the "smoothed" representation is computed, the amount of smoothing that
was performed is reported in terms of the "percentage of variability preserved",
which is the variance (explained deviance, in the general case) of the smoothed function values divided by the variance
of the original values (null deviance, in the general case).
Reporting can be switched off with \code{verbose = FALSE}.

The \code{...} arguments supplies arguments to both the
spline basis (via \code{\link[mgcv:s]{mgcv::s()}}) and the estimation (via
\code{\link[mgcv:magic]{mgcv::magic()}} or \code{\link[mgcv:gam]{mgcv::gam()}}), most important:
\itemize{
\item how many basis functions \code{k} the spline basis should have, the default is
}
\enumerate{
\item 
}
\itemize{
\item which type of spline basis \code{bs} should be used, the default is cubic
regression splines (\code{"cr"}) - a \code{family}-argument to the fitters for data for
which squared errors are not a reasonable criterion for the representation
accuracy (see \code{\link[mgcv:family.mgcv]{mgcv::family.mgcv()}} for what's available).
\item an \code{sp}-argument for manually fixing the amount of smoothing (see
\code{\link[mgcv:s]{mgcv::s()}}), which (drastically) reduces the computation time.
}

If \strong{\code{global == TRUE}}, the routine first takes a subset of curves (10\\% of
curves sampled deterministically, at most 100, at least 5) on which smoothing
parameters per curve are estimated and then uses the mean of the log
smoothing parameter of those for all curves. This can be much faster than
optimizing the smoothing parameter for each curve on large datasets. For very
sparse data, it would be preferable to estimate a joint smoothing parameter
directly for all curves, this is \emph{not} what's implemented here.
}
\section{Methods (by class)}{
\itemize{
\item \code{data.frame}: convert data frames

\item \code{matrix}: convert matrices

\item \code{numeric}: convert matrices

\item \code{list}: convert lists

\item \code{tfd}: convert \code{tfd} (raw functional data)

\item \code{tfb}: convert \code{tfb}: modify basis representation, smoothing.

\item \code{default}: convert \code{tfb}: default method, returning prototype when data is missing
}}

\seealso{
\code{\link[mgcv:smooth.terms]{mgcv::smooth.terms()}} for spline basis options.
}
