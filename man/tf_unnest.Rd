% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidyr.R
\name{tf_unnest}
\alias{tf_unnest}
\alias{tf_unnest.tf}
\alias{tf_unnest.data.frame}
\title{Turn (data frames with) \code{tf}-objects / list columns into "long" tables.}
\usage{
tf_unnest(data, cols, arg, interpolate = TRUE, ...)

\method{tf_unnest}{tf}(data, cols, arg, interpolate = TRUE, ...)

\method{tf_unnest}{data.frame}(
  data,
  cols,
  arg,
  interpolate = TRUE,
  keep_empty = FALSE,
  ptype = NULL,
  names_sep = "_",
  names_repair = "check_unique",
  ...
)
}
\arguments{
\item{data}{a data.frame or a \code{tf}-object}

\item{cols}{<\code{\link[tidyr:tidyr_tidy_select]{tidy-select}}> List-columns to unnest.

When selecting multiple columns, values from the same row will be recycled
to their common size.}

\item{arg}{optional values for the \code{arg} argument of
\code{\link[=tf_evaluate]{tf_evaluate()}}}

\item{interpolate}{return function values for \code{arg}-values not on original grid?
Defaults to \code{TRUE}.}

\item{...}{not used currently}

\item{keep_empty}{By default, you get one row of output for each element
of the list that you are unchopping/unnesting. This means that if there's a
size-0 element (like \code{NULL} or an empty data frame or vector), then that
entire row will be dropped from the output. If you want to preserve all
rows, use \code{keep_empty = TRUE} to replace size-0 elements with a single row
of missing values.}

\item{ptype}{Optionally, a named list of column name-prototype pairs to
coerce \code{cols} to, overriding the default that will be guessed from
combining the individual values. Alternatively, a single empty ptype
can be supplied, which will be applied to all \code{cols}.}

\item{names_sep}{If \code{NULL}, the default, the outer names will come from the
inner names. If a string, the outer names will be formed by pasting
together the outer and the inner column names, separated by \code{names_sep}.}

\item{names_repair}{Used to check that output data frame has valid
names. Must be one of the following options:
\itemize{
\item \verb{"minimal}": no name repair or checks, beyond basic existence,
\item \verb{"unique}": make sure names are unique and not empty,
\item \verb{"check_unique}": (the default), no name repair, but check they are unique,
\item \verb{"universal}": make the names unique and syntactic
\item a function: apply custom name repair.
\item \link[tidyr]{tidyr_legacy}: use the name repair from tidyr 0.8.
\item a formula: a purrr-style anonymous function (see \code{\link[rlang:as_function]{rlang::as_function()}})
}

See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for more details on these terms and the
strategies used to enforce them.}
}
\value{
a "long" data frame with \code{tf}-columns expanded into \verb{arg, value}-
columns.
}
\description{
Similar in spirit to \code{\link[tidyr:unnest]{tidyr::unnest()}}, the reverse of \code{\link[=tf_nest]{tf_nest()}}.
The \code{tf}-method simply turns a single \code{tfd} or \code{tfb} vector into a "long" \code{\link[=tibble]{tibble()}}.
}
\details{
\itemize{
\item Caution -- uses slightly different defaults for names of unnested columns
than \code{tidyr::unnest()}.
\item For \code{data.frames}, \strong{make sure to have an ID column in your data before unnesting!}
If it does not include an ID column with a unique identifier for each row, you will not
be able to match arg-value pairs to the different functions after unnesting.
}
}
\seealso{
tf_evaluate.data.frame()

Other tidyfun data wrangling functions: 
\code{\link{tf_evaluate.data.frame}()},
\code{\link{tf_gather}()},
\code{\link{tf_nest}()},
\code{\link{tf_spread}()}
}
\concept{tidyfun data wrangling functions}
