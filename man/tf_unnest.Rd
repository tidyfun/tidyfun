% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidyr.R
\name{tf_unnest}
\alias{tf_unnest}
\title{Turn data frames with \code{tf}-objects / list columns into "long" tables.}
\usage{
tf_unnest(
  data,
  cols,
  .arg,
  .id = "id",
  keep_empty = FALSE,
  ptype = NULL,
  names_sep = "_",
  names_repair = "check_unique",
  try_dropping = TRUE
)
}
\arguments{
\item{data}{a data frame}

\item{cols}{<\code{\link[tidyr:tidyr_tidy_select]{tidy-select}}> Columns to unnest.

If you \code{unnest()} multiple columns, parallel entries must be of
compatible sizes, i.e. they're either equal or length 1 (following the
standard tidyverse recycling rules).}

\item{.arg}{optional values for the \code{arg} argument of
\code{\link[=tf_evaluate.data.frame]{tf_evaluate.data.frame()}}}

\item{.id}{\Sexpr[results=rd, stage=render]{lifecycle::badge("deprecated")}:
convert \code{df \%>\% unnest(x, .id = "id")} to \verb{df \%>\% mutate(id = names(x)) \%>\% unnest(x))}.}

\item{keep_empty}{By default, you get one row of output for each element
of the list your unchopping/unnesting. This means that if there's a
size-0 element (like \code{NULL} or an empty data frame), that entire row
will be dropped from the output. If you want to preserve all rows,
use \code{keep_empty = TRUE} to replace size-0 elements with a single row
of missing values.}

\item{ptype}{Optionally, supply a data frame prototype for the output \code{cols},
overriding the default that will be guessed from the combination of
individual values.}

\item{names_sep}{If \code{NULL}, the default, the names will be left
as is. In \code{nest()}, inner names will come from the former outer names;
in \code{unnest()}, the new outer names will come from the inner names.

If a string, the inner and outer names will be used together. In \code{nest()},
the names of the new outer columns will be formed by pasting together the
outer and the inner column names, separated by \code{names_sep}. In \code{unnest()},
the new inner names will have the outer names (+ \code{names_sep}) automatically
stripped. This makes \code{names_sep} roughly symmetric between nesting and
unnesting.}

\item{names_repair}{Used to check that output data frame has valid
names. Must be one of the following options:
\itemize{
\item "minimal": no name repair or checks, beyond basic existence,
\item "unique": make sure names are unique and not empty,
\item "check_unique": (the default), no name repair, but check they are unique,
\item "universal": make the names unique and syntactic
\item a function: apply custom name repair.
\item \link[tidyr]{tidyr_legacy}: use the name repair from tidyr 0.8.
\item a formula: a purrr-style anonymous function (see \code{\link[rlang:as_function]{rlang::as_function()}})
}

See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for more details on these terms and the
strategies used to enforce them.}

\item{try_dropping}{should \code{tf_unnest} try to avoid duplicating \code{id} or \code{arg}
columns? Defaults to TRUE.}
}
\value{
a "long" data frame with  \code{tf}-columns expanded into \verb{id, arg, value}-
columns.
}
\description{
Similar in spirit to \code{\link[tidyr:nest]{tidyr::unnest()}}, the reverse of \code{\link[=tf_nest]{tf_nest()}}.
Caution -- uses slightly different defaults for names of unnested columns
than \code{tidyr::unnest()}.
\strong{Add an ID column to your data before unnesting!} If your nested data does
not include an ID column with a unique identifier for each row, you will not
be able to match arg-value pairs to different functions after unnesting, see
\code{.id}-argument below.
}
\seealso{
tf_gather(), tf_nest(), tf_evaluate.data.frame()
}
